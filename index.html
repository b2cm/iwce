<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Inter-Wallet Credential Exchange</title>
    <script
      src="https://www.w3.org/Tools/respec/respec-w3c"
      class="remove"
      defer
    ></script>
    <script class="remove">
      // All config options at https://respec.org/docs/
      var respecConfig = {
        editors: [
            {
              name: "Christoph Menzer",
              company: "BCCM at Hochschule Mittweida",
              companyURL: "https://blockchain.hs-mittweida.de",
            }, {
              name: "Sarah Otto",
              company: "BCCM at Hochschule Mittweida",
              companyURL: "https://blockchain.hs-mittweida.de",
            },
        ],
        github: "b2cm/iwce",
        shortName: "iwce",
        xref: "web-platform",
        noRecTrack: true,
        localBiblio: {
          applinks: {
            title: "Handling Android App Links. Android Developers",
            href: "https://developer.android.com/training/app-links",
            publisher: "Google Inc.",
          },
          universallinks: {
            title: "Allowing Apps and Websites to Link to Your Content. Apple Developer Documentation",
            href: "https://developer.apple.com/documentation/uikit/inter-process_communication/allowing_apps_and_websites_to_link_to_your_content",
            publisher: "Apple Inc.",
          },
          didconfiguration: {
            title: "Well Known DID Configuration",
            href: "https://identity.foundation/specs/did-configuration/",
            publisher: "Decentralized Identity Foundation",
          },
        },
      };
    </script>
  </head>
  <body>

    <section id="abstract">

      <p>
        Inter-Wallet Credential Exchange describes a simple way to exchange identity information in a secure, decentralized and scalable manner.
        It uses standardized data structures, formats and transport protocols to enable applications (particulary identity wallets) from different manufacturers to communicate with each other, without a third party or an intermediary.
        The main purpose of this approach is to establish a claim-based identity management model in the world wide web.
      </p>

    </section>

    <section id="sotd">
      <p>This is required.</p>
    </section>

    <section class="informative">

      <h2>Introduction</h2>

      <p>
        In the real world an identity could be proofed physically showing the own id card, driver's license or student id to any other person requesting it.
        In the digital world, things become more complicated.
        Here a way expressing the information of such credentials is needed, also a way proofing possion of it and a way sending it to a requesting party.
      </p>

      <p>
        The Verifiable Credentials Data Model [[vc-data-model]] is used to solve the first aformentioned challenge.
        The ecosystem of this model consists of multiple roles and their actors identifiable by some kind of identifiers.
        These can be decentralized identifiers (DIDs) [[did-core]], Uniform Resource Identifiers (URIs) [[rfc3986]], Uniform Resource Locators (URLs) and so on.
        By the use of DIDs and their corresponding DID documents, the identidier is fully under control of its owning entity.
        Therefore, they are neither trustworthy nor make any statement about their owner itself.
      </p>

      <p>
        To address this problem, verifiable credentials (VCs) and their corresponding verifiable presentations (VPs) can be used.
        VCs are cryptographically signed by a (supposedly) trusted issuer and make claims about the aformentioned owner of an identifier.
        This owner is refered to as holder.
        If the holder wishes to proof ownership of a VC, VPs are used.
        These are cryptographically signed by the holder to prove control of the identifier.
        Therefor VPs solve the second listed challenge mentioned at the beginning.
      </p>

      <p>
        The Inter Wallet Credential Exchange uses DIDs, VCs and VPs in conjunction with HTTPS to transport identity information between two applications directly.
        For optimal decentralization, it is recommended to use special URLs known as Universal-Links [[universallinks]] or App-Links [[applinks]] respectively.
        In the case of web applications running on a desktop, in conjunction with a mobile device, these links can be transferred using a QR code.
        So Inter Wallet Credential Exchange proposes an solution to the third listed challlenge in digitalization of credentials.
      </p>

    </section>

    <section>

      <h2>Scope</h2>

      <p>
        This proposal mainly specifies two data structures, their encoding and transport over HTTPS.
        It describes the use of Universal- or App-Links and their advantages in terms of decentralization.
        Furthermore, VCs and an additional special data structure are used so that it is possible for users to reveal only certain personal information, without the complexity of zero-knowledge proofs.
      </p>

      <p>
        Out of scope are any semantics of concrete VCs and related data structures.
        Moreover, no detailed implementation instructions are given with regard to different development environments, programming languages and operating systems.
        Additionally the issuing process of a VC isn't addressed.
        This process is designed by each service acting as issuer individually.
        It is assumed that corresponding VCs have already been issued to a user in an issuer's wallet application.
      </p>

      <p>
        Inter-Wallet Credential Exchange is not a solution for single sign-on (SSO) and not about the login process currently mostly solved with username and password.
        Rather, the aim is to speed up the registration process for new services and to replace the login with passwordless procedures.
        The latter takes place exclusively within a service's own domain (see [[[#sds]]] and [[[#anti-correlation]]]).
        However, the authentication of devices or applications against their own backend is not the actual concern either.
        The DIDs described here or other asymmetric cryptography methods (e.g. Web Authentication) are suitable for this .
        For existing systems, it is also conceivable that other authentication methods that are currently in widespread use, such as the legacy username and password, or centralized schemes such as OAuth or OpenID, could be used to authenticate within one's domain.
      </p>

    </section>

    <section class="informative">

      <h2>Terminology</h2>

      <dl class="termlist">

        <dt><dfn>blockchain</dfn></dt>
        <dd>
          description
        </dd>

        <dt><dfn>content-addressable storage</dfn></dt>
        <dd>
          description
        </dd>

        <dt><dfn>credential request</dfn></dt>
        <dd>
          description
        </dd>

        <dt><dfn>credential response</dfn></dt>
        <dd>
          description
        </dd>
      </dl>

        <dt><dfn>decentralized identifier</dfn></dt>
        <dd>
          description
        </dd>

        <dt><dfn>DID document</dfn></dt>
        <dd>
          description
        </dd>

        <dt><dfn>DID method</dfn></dt>
        <dd>
          description
        </dd>

        <dt><dfn>DID resolver</dfn></dt>
        <dd>
          description
        </dd>

        <dt><dfn>digital identity</dfn></dt>
        <dd>
          description
        </dd>
      </dl>

        <dt><dfn>identifier</dfn></dt>
        <dd>
          description
        </dd>

        <dt><dfn>perfect forward secrecy</dfn></dt>
        <dd>
          description
        </dd>

        <dt><dfn>plaintext credential</dfn></dt>
        <dd>
          description
        </dd>

        <dt><dfn>public key infrastructure</dfn></dt>
        <dd>
          description
        </dd>

        <dt><dfn>single sign-on</dfn></dt>
        <dd>
          description
        </dd>

        <dt><dfn>Transport Layer Security</dfn></dt>
        <dd>
          description
        </dd>

        <dt><dfn>verifiable credential</dfn></dt>
        <dd>
          description
        </dd>

        <dt><dfn>verifiable presentation</dfn></dt>
        <dd>
          description
        </dd>

        <dt><dfn>wallet</dfn></dt>
        <dd>
          description
        </dd>

        <dt><dfn>zero-knowledge proof</dfn></dt>
        <dd>
          description
        </dd>

      </dl>

    </section>

    <section>

      <h2>Assumptions</h2>

      <section class="informative">

        <h2>Decentralized Identifiers</h2>

        <p>
          DIDs as defined in [[did-core]] are a new type of identifier.
          They are generated and controlled by an entity itself.
          Therefor the number of DIDs an entity can create is unlimited.
          Proof of control over a DID is provided by cryptographic methods, e.g. digital signatures.

        </p>

        <p>
          A DID contains the names of a schema and a DID method as well as the identifier itself. These parts are separated by a colon:
        </p>

        <aside class="example">
          <pre class="nohighlight">
            did:example:123456789abcdefghi
          </pre>
        </aside>

        <p>
          The schema denotes that it is a DID. The DID method identifies the way the identifier can be created and managed.
          The W3C maintains an official list of DID methods and their specifications for this purpose [[did-spec-registries]].
          The specification of a DID method contains information about all important operations, such as creating, reading, updating and deleting DIDs.
        </p>

        <p>
          A DID is resolved by a DID resolver into a DID document.
          This contains additional information about a DID, such as further public keys, authentication and authorization methods, or so-called service endpoints.
          The latter are details of services or storage locations that can be linked to the identifier.
          A DID document never contains personal information.
        </p>

        <aside class="note" title="DID documents">
          <p>
            It is important to understand, that DID documents DO NOT contain any personally identifiable information (PII).
            They are only used to describe some technical information about the identifier.
            These can be for example public keys, methods for verification, authentication and assertion, or service endpoints.
          </p>
        </aside>

        <p>
          In some DID methods, the identifiers have cryptographic material or a fingerprint of a public key, just as they do in a blockchain.
          In this way, a DID can authenticate directly against a smart contract in the corresponding blockchain.
          Furthermore, some signature methods such as the Elliptic Curve Digital Signature Algorithm (ECDSA) allow the recovery of the public key directly from a signature.
          This feature makes it possible to use a signed message directly for authentication between two hosts.
          The method for generating the identifier, e.g. a DID or an address in the context of blockchain, from a public key is usually known.
          From this point of view, it is not urgent to keep a DID document as long as the relationship between private key, public key and identifier is computable.
          For example, in the ETHR DID Method (`did:ethr:xyz`) the DID document is created by the DID resolver.
        </p>

      </section>

      <section class="informative" id="selective-disclosure">

        <h2>Verifiable Credentials and Selective Disclosure</h2>

        <p>
          This proposal makes use of VCs and VPs according to the [[[vc-data-model]]].
          Additionally it supports a special way implementing the selective disclosure feature.
          This feature gives the credential holder the oppurtunity to choose, which attributes will be shown to the verifier.
          To achive this, every attribute value a credential contains, is hashed with a salt.
          The final verifiable credential will only contain this hashes - the salts and the values are stored in a separate json data object, called the plaintext credential.
          The following example will show such a plaintext credential and its corresponding VC.
        </p>

        <aside class="example">
          <p>Plaintext credential</p>
          <pre class="json">
            {
              "id": "did:example:0x1611994c317bed3102D65A93B667Dbe0591Da41c",
              "type": ["HashedPlaintextCredential2021","NameAgeCredential"],
              "hashAlg": "keccak-256",
              "name": {
                  "value": "Max",
                  "salt": "dc0931a0-60c6-4bc8-a27d-b3fd13e62c63",
              },
              "age": {
                  "value": 20,
                  "salt": "3e9bacd3-aa74-42c1-9895-e490e3931a73",
              },
            }
          </pre>
        </aside>

        <aside class="example">
          <p>Corresponding verifiable credential</p>
          <pre class="json">
            {
              "@context": ["https://www.w3.org/2018/credentials/v1",
                  "https://some.example.com/credentials/ld-context/"],
              "type": ["VerifiableCredential"],
              "credentialSubject": {
                  "id": "did:example:0x1611994c317bed3102D65A93B667Dbe0591Da41c",
                  "type": "NameAgeCredential",
                  "name": "0xd8925653ed000200d2b491bcabe2ea69f378abb91f056993a6d3e3b28ad4ccc4",
                  "age": "0x43bde6fcd11015c6a996206dadd25e149d131c69a7249280bae723c6bad53888"
              },
              "issuer": "did:example:0x6d32738382c6389eF0D79045a76411C42Fff3a5e",
              "issuanceDate": "2020-11-30T11:06:39.423520Z",
              "proof": {
                  "type": "EcdsaSecp256k1RecoverySignature2020",
                  "proofPurpose": "assertionMethod",
                  "verificationMethod": "did:example:0x6d32738382c6389eF0D79045a76411C42Fff3a5e",
                  "created": "2020-11-30T11:06:39.497073Z",
                  "jws": "ey..E="
              }
            }
          </pre>
        </aside>

        <p>
          VCs are data structures making statements about a person or an object according to the principles of claim-based identity.
          They are cryptographically verifiable because they are signed by an issuer.
          The claims are simple statements associated with an identifier and some metadata.
          Basically, anyone can act as an issuer, e.g., a trusted entity or even oneself.
          The latter type of VCs are called self-issued credentials and are useful, for example, for delegating one's own credential to another identifier.
          What should be considered a trusted entity for certain statements is not part of the proposal.
        </p>

      </section>

      <section class="informative">

        <h2>Verifiable Credentials and Verifiable Presentations</h2>

        <p>
          The VCs are issued to a subject (holder) and its identifier, e.g. a DID.
          This holder can generate a VP with one or more VCs, in which he can prove by a signature that he controls the identifier(s) of one or more VCs.
          The aggregation of this information typically expresses some aspect of a person, organization or other entity.
          He finally sends the VP to a verifier that can cryptographically validate the VCs trustworthiness.
        </p>

        <aside class="example">
          <p>Corresponding verifiable presentation</p>
          <pre class="json">
            {
              "@context": [
                "https://www.w3.org/2018/credentials/v1",
              ],
              "type": "VerifiablePresentation",
              "verifiableCredential": [{
                "@context": ["https://www.w3.org/2018/credentials/v1",
                    "https://some.example.com/credentials/ld-context/"],
                "type": ["VerifiableCredential"],
                "credentialSubject": {
                    "id": "did:example:0x1611994c317bed3102D65A93B667Dbe0591Da41c",
                    "type": "NameAgeCredential",
                    "name": "0xd8925653ed000200d2b491bcabe2ea69f378abb91f056993a6d3e3b28ad4ccc4",
                    "age": "0x43bde6fcd11015c6a996206dadd25e149d131c69a7249280bae723c6bad53888"
                },
                "issuer": "did:example:0x6d32738382c6389eF0D79045a76411C42Fff3a5e",
                "issuanceDate": "2020-11-30T11:06:39.423520Z",
                "proof": {
                    "type": "EcdsaSecp256k1RecoverySignature2020",
                    "proofPurpose": "assertionMethod",
                    "verificationMethod": "did:example:0x6d32738382c6389eF0D79045a76411C42Fff3a5e",
                    "created": "2020-11-30T11:06:39.497073Z",
                    "jws": "ey..E="
                }
              }],
              "proof": [{
                  "type": "EcdsaSecp256k1RecoverySignature2020",
                  "proofPurpose": "authentication",
                  "verificationMethod": "did:example:0x1611994c317bed3102D65A93B667Dbe0591Da41c",
                  "challenge": "1f44d55f-f161-4938-a659-f8026467f126",
                  "created": "2020-11-30T11:06:39.497073Z",
                  "jws": "ey..n="
              }]
            }
          </pre>
        </aside>

        <p>
          In addition, a VP itself can also have an identifier.
          It is also possible for each of the VCs to be issued to a different identifier.
          For each of these identifiers (subject), the corresponding proof can be included in the array of proofs in the VP.
          A challenge within one or more proofs authenticates for example a session.
        </p>

        <aside class="example">
          <p>Verifiable presentation containing an identifier and several verifiable credentials, as well as their associated proofs</p>
          <pre class="nohighlight">
            {
              "@context": [
                "https://www.w3.org/2018/credentials/v1",
              ],
              <span style="color: #008000; font-weight: bold">"id": "did:anotherexample:xyv2-xzpq-q9wa-p7t"</span>,
              "type": "VerifiablePresentation",
              "verifiableCredential": [{
                "@context": ["https://www.w3.org/2018/credentials/v1",
                    "https://some.example.com/credentials/ld-context/"],
                "type": ["VerifiableCredential"],
                "credentialSubject": {
                    <span style="color: #008000; font-weight: bold">"id": "did:example:0x1611994c317bed3102D65A93B667Dbe0591Da41c"</span>,
                    "type": "NameCredential",
                    "name": "0xd8925653ed000200d2b491bcabe2ea69f378abb91f056993a6d3e3b28ad4ccc4",
                },
                "issuer": "did:example:0x6d32738382c6389eF0D79045a76411C42Fff3a5e",
                "issuanceDate": "2020-11-30T11:06:39.423520Z",
                "proof": {
                    "type": "EcdsaSecp256k1RecoverySignature2020",
                    "proofPurpose": "assertionMethod",
                    "verificationMethod": "did:example:0x6d32738382c6389eF0D79045a76411C42Fff3a5e",
                    "created": "2020-11-30T11:06:39.497073Z",
                    "jws": "ey..E="
                }
              }, {
                "@context": ["https://www.w3.org/2018/credentials/v1",
                    "https://some.example.com/credentials/ld-context/"],
                "type": ["VerifiableCredential"],
                "credentialSubject": {
                    <span style="color: #008000; font-weight: bold">"id": "did:example:0x7c0296fb88ec930a2a31361ca1b579603bc18892"</span>,
                    "type": "AgeCredential",
                    "age": "0x43bde6fcd11015c6a996206dadd25e149d131c69a7249280bae723c6bad53888"
                },
                "issuer": "did:example:0x6d32738382c6389eF0D79045a76411C42Fff3a5e",
                "issuanceDate": "2020-11-30T11:06:39.423520Z",
                "proof": {
                    "type": "EcdsaSecp256k1RecoverySignature2020",
                    "proofPurpose": "assertionMethod",
                    "verificationMethod": "did:example:0x6d32738382c6389eF0D79045a76411C42Fff3a5e",
                    "created": "2020-11-30T11:06:39.497073Z",
                    "jws": "ey..G"
                }
              }],
              "proof": [{
                  "type": "EcdsaSecp256k1RecoverySignature2020",
                  "proofPurpose": "authentication",
                  <span style="color: #008000; font-weight: bold">"verificationMethod": "did:example:0x1611994c317bed3102D65A93B667Dbe0591Da41c"</span>,
                  "challenge": "1f44d55f-f161-4938-a659-f8026467f126",
                  "created": "2020-11-30T11:06:39.497073Z",
                  "jws": "ey..v="
                }, {
                  "type": "EcdsaSecp256k1RecoverySignature2020",
                  "proofPurpose": "authentication",
                  <span style="color: #008000; font-weight: bold">"verificationMethod": "did:example:0x7c0296fb88ec930a2a31361ca1b579603bc18892"</span>,
                  "challenge": "1f44d55f-f161-4938-a659-f8026467f126",
                  "created": "2020-11-30T11:06:39.497073Z",
                  "jws": "ey..6"
                }, {
                  "type": "EcdsaSecp256k1RecoverySignature2020",
                  "proofPurpose": "authentication",
                  <span style="color: #008000; font-weight: bold">"verificationMethod": "did:anotherexample:xyv2-xzpq-q9wa-p7t"</span>,
                  "challenge": "1f44d55f-f161-4938-a659-f8026467f126",
                  "created": "2020-11-30T11:06:39.497073Z",
                  "jws": "ey..r"
                }]
            }
          </pre>
        </aside>

      </section>

      <section class="informative">

        <h2>Verifiable Credentials and Revocation</h2>

        <p>
          In addition to an expiration date (`expirationDate` or `validUntil`) for credentials, issuers also have the option to revoke it.
          For this purpose, the [[[vc-data-model]]] defines the property `credentialStatus`, which links to a revocation list.
          This list can be stored on a blockchain, a content addressable storage (CAS) or any other (web)server.
        </p>

        <aside class="example">
          <p>Expiration date and status in a verifiable credential</p>
          <pre class="json">
            {
                "expirationDate": "2020-01-01T19:23:24Z",
                "credentialStatus": {
                  "id": "0x06012c8cf97bead5deae237070f9587f8e7a266d",
                  "type": "EthereumMainnetStatusList2021"
                },
            }
        </pre>
        </aside>
      </section>

      <section class="informative" id="uniapplinks">

        <h2>Universal / App Links</h2>

        <p>
          Universal or app links are a way in mobile operating systems to retrieve certain data from an app using a URL.
          For Apple's iOS they are documented as universal links [[universallinks]], for Google they are called Android App Links [[applinks]].
          These links are a form of deep links that are handled specifically in the operating systems.
          During the installation of an app, a handler for a specific URL is created in the operating system that uniquely identifies the app.
          To prove ownership of a URL, a check is made for a specific machine-readable document that must be provided under the URLs domain.
          After this check is successful, requests to this URL are passed directly to the installed app without any further interaction from the user.
          Binding to a domain ensures uniqueness and the mandatory use of HTTPS ensures authenticity and secrecy.
        </p>

        <p>
          If a request is made to the URL and there is no corresponding app installed, it will be opened in the browser.
          The request therefore does not end in an error state, but can be answered by the own web server as desired.
          For example, the user gets a hint to install the corresponding app or is redirected to an online application.
        </p>

      </section>

    </section>

    <section>

      <h2>Protocol Flow</h2>

      <section>

        <h2>Credential Request</h2>

        <p>
          To request VCs within a VP the following simple JSON data structure MUST be used, which MUST then be encoded with Base64url [[rfc4648]] and attached as query parameter with key `Ã¬wce` to a URL.
          The URIs used comply with the [[[rfc3986]]] specification.
          VCs and VPs are compliant to the [[[vc-data-model]]].
        </p>

        <p>
          A credential request is defined with the following properties:
          <dl>

          <dt>type</dt>
            <dd>
              The `type` property is required and MUST be an URI. The value `"CredentialRequest"` MUST be used to determine that it is a credential request.
            </dd>

          <dt>accept</dt>
            <dd>
              The `accept` property is required and describes the accepted data of a response to a request. It is defined with the following properties:
            <dl>

              <dt>type</dt>
              <dd>
                The `type` property is required and MUST be an URI.
                The value `"CredentialResponse"` MUST be used to determine that the requested data has to be provided in the form of a credential response.
              </dd>

              <dt>verifiablePresentation<dt>
                <dd>
                  The `verifiablePresentation` property is required.
                  <dl>

                    <dt>type</dt>
                      <dd>
                        The `type` property is required and MUST be an URI.
                        It denotes the expected type of the verifiable presentation.
                      </dd>

                    <dt>credentialTypes</dt>
                      <dd>
                        The `credentialTypes` property is required and MUST be an array of URIs.
                        It denotes the accepted URIs of verifiable credential types within a verifiable presentation.
                      </dd>
                  </dl>
                </dd>

              <dt>selectiveDisclosure</dt>
                <dd>
                  The `selectiveDisclosure` property is optional. If it is not set, no method for selective disclosure is accepted.
                  <dl>

                  <dt>type</dt>
                    <dd>
                      The `type` property is required and MUST be an URI.
                      It denotes the expected method of the selective disclosure feature.
                    </dd>

                  <dt>requiredProperties</dt>
                    <dd>
                      The `requiredProperties` property is is type specific.
                      For the selective disclosure feature proposed in section [[[#selective-disclosure]]] the `requiredProperties` property MUST be an object that contains one or more arrays of strings corresponding to the property names of one or more plaintext credentials mandatorily beeing disclosed.
                      To refer to properties in nested objects within the plaintext credential the notation `parentObjectKey.childPropertyKey` MUST be used.
                      The key of each set MUST correspond to the credential type specified in property `credentialTypes`.
                      Which properties are then really returned is not guaranteed and has to be checked in the response.
                    </dd>
                  </dl>
                </dd>

              <dt>endpoint</dt>
                <dd>
                  The `endpoint` property is required. It describes the endpoint to which the requested data has to be sent.
                  <dl>
                    <dt>type</dt>
                      <dd>
                        The `type` property is required and MUST be an URI.
                        It can take either the value `"AppLink"` or `"WebAddress"`.
                        `"AppLink"` determines that the endpoint is a universal or app link and is RECOMMENDED for best decentralization, see section [[[#uniapplinks]]].
                        The value `"WebAddress"` determines that the endpoint is a normal web resource (web address).
                      </dd>
                    <dt>location</dt>
                      <dd>
                        The `location` property is required and MUST be an URL that links to a resource with HTTPS enabled.
                      </dd>
                  </dl>
                </dd>
              </dl>
            </dd>

          <dt>challenge</dt>
            <dd>
              The `challenge` property is required and MUST be a long random number.
              It is RECOMMENDED to use at least 128 bit. For example, an UUID [[rfc4122]] might be helpful for this task.
              The challenge is computed by the verifier and MUST have a Time to Live (TTL).
            </dd>

          <dt>domain</dt>
            <dd>
              The `domain` property is optional and MUST be an URI.
              It is used to announce domain-specific extensions in a credential request.
            </dd>

          </dl>
        </p>

        <aside class="example">
          <p>Credential request data object</p>
          <pre class="json">
            {
                "type": "CredentialRequest",
                "accept": {
                    "type": "CredentialResponse",
                    "verifiablePresentation": {
                        "type": "VerifiablePresentation",
                        "credentialTypes": ["AgeCredential","NameCredential"],
                    },
                    "selectiveDisclosure": {
                        "type": "HashedPlaintextCredential2021",
                        "requiredProperties": {
                            "AgeCredential": ["age"]
                        },
                    },
                    "endpoint": {
                        "type": "AppLink",
                        "location": "https://verifier-app.another-example.com/responses"
                    }
                },
                "challenge": "1f44d55f-f161-4938-a659-f8026467f126",
                "domain": "example.com"
            }
          </pre>
        </aside>

        <aside class="example">
          <p>Encoded credential request</p>
          <pre class="nohighlight">
            https://issuer-app.example.com/requests?<span style="color: #008000; font-weight: bold">iwce=eyAidHlwZSI6ICJDc...IgfQ</span>
          </pre>
        </aside>

        <aside class="note" title="QR codes">
          <p>
            For use with web applications on a desktop, the URL including the encoded credential request can be represented as a QR code.
            Depending on the type used, there may be restrictions on the amount of data that can be encoded.
            Since the challenge has a TTL, the QR code has to be rerendered frequently.
          </p>
        </aside>

      </section>

      <section>

        <h2>Credential Response</h2>

        <p>
          To respond to a request for a VP the following data structure MUST be used, which MUST be encoded with Base64url [[rfc4648]] and attached as a query parameter with key `iwce` to a URL.
          The URIs used comply with the [[[rfc3986]]] specification.
          VCs and VPs are compliant to the [[[vc-data-model]]].
        </p>

        <p>
          <dl>

            <dt>type</dt>
              <dd>
                The `type` property is required and MUST be an URI.
                The value `"CredentialResponse"` MUST be used to determine that it is a credential response.
              </dd>

            <dt>verifiablePresentation</dt>
              <dd>
                The `verifiablePresentation` property is required and defined as an object that contain exactly one verifiable presentation.
                The proofs within a verifiable presentation MUST contain the `challenge` property that was received with a credential request.
                The proofs can also contain the `domain` property to announce domain-specific extensions
              </dd>

            <dt>selectiveDisclosure<dt>
              <dd>
                The `selectiveDisclosure` property is optional.
                If it is not set, no method for selective disclosure is supported.
                <dl>

                  <dt>type</dt>
                    <dd>
                      The `type` property is required and MUST be an URI.
                      It denotes the expected method of the selective disclosure feature.
                    </dd>

                  <dt>plaintextCredential</dt>
                    <dd>
                      The `plaintextCredential` property is type specific.
                      The expected return value is data conforming to the type information from a credential request.
                      For the selective disclosure feature proposed in section [[[#selective-disclosure]]] the `plaintextCredential` property is defined as an array of objects containing one or more plaintext credentials.
                    </dd>

                </dl>
              </dd>

          </dl>
        </p>

          <aside class="example">
            <p>Credential response data object</p>
            <pre class="json">
              {
                  "type": "CredentialResponse",
                  "verifiablePresentation": {},
                  "selectiveDisclosure": {
                      "type": "HashedPlaintextCredential2021",
                      "plaintextCredential": [{},{}]
                  }
              }
            </pre>
          </aside>

        <aside class="example">
          <p>Encoded credential response</p>
          <pre class="nohighlight">
            https://verifier-app.another-example.com/responses?<span style="color: #008000; font-weight: bold">iwce=JWZXJpZmlhYmxlUHJ...JodH</span>
          </pre>
        </aside>

      </section>

    </section>

    <section id="sds">

      <h2>Strict Domain Separation</h2>

      <p>
        The use of multiple proofs in a VP makes it possible to strictly separate the domains of identity information.
        For best decentralization, VCs SHOULD only be issued within a domain and SHOULD only be stored in a domains own application.
        To be faithful to the concept of Inter-Wallet Credential Exchange, the only way to exchange VCs with external or third-party applications MUST be the use of VPs.
        The private key of a subject's identifier MUST NOT leave its own applications within a domain.
        This has several advantages:
      </p>

      <ul>
        <li>an issuer can decide how to store the private keys of a subject it issues verifiable credentials to (security levels)</li>
        <li>an issuer can enforce security mechanisms such as two-factor authentication</li>
        <li>an issuer can customize the issuance process to meet its specific needs</li>
        <li>areas of responsibility are clearly separated</li>
        <li>personal data is managed where it already exists, within a domain</li>
      </ul>

      <p>
        Since the proofs in a VP can be made for different identifiers, an issuers application is able to interoperate with different types of identifiers.
        For example, the identfier of a VP can be an address in blockchain A and the identfiers of the VCs are DIDs anchored in blockchain B.
        The latter is a blockchain in the issuer's domain, blockchain A is that of a third party application.
        In that way a user can prove control over an address in any blockchain or any other identfier in combination with verifiable personal information.
        For this to work, both issuer and verifier MUST implement all methods of the identifiers used.
      </p>

      <p>
        The issuing process is domain specific and an issuer decides what types of identifiers he is using for its own VCs.
        An issuer SHOULD use DIDs as specified in [[[did-core]]] to authenticate a VC on a device (`id` of `credentialSubject`) to the own backend.
        An issuer MAY use DIDs for the `issuer` property to authenticate himself to the verifier.
        In that case the [[[didconfiguration]]] SHOULD be used for trust, see [[[#trust]]] for more details.
      </p>

    </section>

    <section class="informative">

      <h2>User Experience</h2>

      <p>
        Considerations about end-user experience are closely related to the use of app or universal links and VCs/VPs.
        App or universal links enable a seemless user experience during exchange of VPs between apps on the user's device, because, when implemented correctly, they identify the app the operating system should open.
        Additionally, these links are normal URLs and can be represented in any form a URL can take, e.g. as QR code.
        Therefore, an exchange between different devices (smartphone and desktop) is possible without loss in user experience, because the QR code can be scanned with every app capable of doing so and the user is redirected to the requested app.
      </p>

      <p>
        With VCs/VPs it is possible to exchange personal information in a verifiable and data-conserving manner.
        In most use cases they simplify the disclosure of these information during for example a registration process.
        Using VCs/VPs the user must not input the information by hand but only has to send a VP.
        The service requesting the information could rely on them, because they are signed by an issuer (only if the service trusts the issuer).
      </p>

      <p>
        Additionally, this proposal enables every service provider that has an own app including credential and their exchange functionality in its own app without relying on a central so called identity wallet to store the issued credential.
        From the user perspective he or she only has to rely on the issuer and its application, not in an intermediary wallet service or app for storing the credentials.
      </p>

    </section>

    <section class="informative">

      <h2>Security Considerations</h2>

      <section>

        <h2>Perfect Forward Secrecy</h2>

        <p>
          Because HTTPS is used to transport credential requests and credential responses between two applications, perfect forward secrecy (PFS) is substantial in most of the available implementations.
          Note, that this applies only to the network connection while requests or responses are made.
          The including VP and its VCs signed by the holder and one or more issuers are unaffected.
          When using QR codes for a request, this security requirement is obsolete.
        </p>

        <p>
          Since Transport Layer Security (TLS) operates on the network layer, it ensures that the information transferred within a URL is also protected (e.g. the query).
        </p>

      </section>

      <section id="trust">

        <h2>Trust</h2>

        <p>
          Because HTTPS is used to transport credential requests and credential responses between two applications, the underlying PKI system of TLS (X.509) builds trust for this connection, in that way, that the communication endpoints are the intended ones.
          This is helpful to identify the applications that want to do a credential exchange.
        </p>

        <p>
          Since DIDs are out of trust HTTPS can be used to map a DID to a domain.
          This is most useful for issuers, since larger institutions usually use TLS certificates these days anyway.
          The [[[didconfiguration]]] specification describes an approach which makes use of Well-Known URIs [[rfc8615]].
        </p>

      </section>

    </section>

    <section class="informative">

      <h2>Privacy Considerations</h2>

      <section id="anti-correlation">

        <h2>Anti-correlation</h2>

        <p>
          An important goal in dealing with digital identities is to avoid or at least make it more difficult to conduct in-depth analyses of user behavior.
          The concept of SSO in particular does exactly the opposite, even across multiple services and for each individual login process.
          In the approach of the Inter-Wallet Credential Exchange, this is complicated by two conceptual improvments.
          First, technical authentication via DIDs or other types of identfiers takes place only within the domain of a single service and is strictly separated from the exchange of a user's identity information across domain boundaries (see section [[[#sds]]]).
          Second, even the identifiers, e.g., in the form of a DID, are not limited to a single, unique one per user.
          When used in VCs, it is recommended that each VC should have a different identifier.
        </p>

        <p>
          Individual aspects of a digital identity are only stored within the app of a service acting as issuer for it.
          Other services that trust the aforementioned one as issuer and are interested in these individual aspects of an identity can submit a request to the app of this issuer to return a VP.
          Further aspects of a digital identity can in turn be requested from apps of other services or issuers in the same way.
          Each app acts as a wallet software and stores private keys that never leave it and are used to authenticate with its own backend (e.g., DID Auth).
          Services acting as issuers also store the VCs they issue to their users only in their own apps on the end devices of them (and possibly as a backup in their own backend).
          Only this app is ultimately able to sign a requested VP because only it has the corresponding private keys.
          The user's own digital identity is thus formed from a large number of apps from different manufacturers or services exchanging VPs with each other.
          As a result the correlation of personal data by intermediaries is made more difficult and  a high degree of decentralization is achieved by the direct exchange of identity information between two apps.
          The private keys stored in the respective apps also relieve the user of the need to enter passwords.
        </p>

      </section>

    </section>

    <section class="informative">

      <h2>Bootstrapping</h2>

      <p>
        An app launched the first time and wanted to authenticate with its backend, it generates and sends a DID to it.
        By doing so, the backend system merely learns about a new device, but does not yet have any verifiable information about the user and his identity.
        Therefor at least one other app should be installed on the user's device that provides a VC accepted by the first app.
        If this isn't the case  a newly computed DID must be associated with a digital identity in some other way.
        In the worst case, the user must visit an issuer in person and identify himself to him (ID card, driver's license, etc.) and transmit the corresponding DID (e.g., by QR code).
        It is also conceivable that some issuers will additionally offer other procedures for proofing identity.
        For example, the combination with an online ID function of the ID card could be a suitable starting point for some issuers.
        In addition, government agencies could also act as issuers and offer VCs in their apps after authentication with the ID card succeeds.
        RFID cards, PINs/TANs/links via e-mail, second devices, and many more are also ways to support bootstrapping during the initial launch of an application on a new end device supporting VCs/VPs.
        The greater the variety of applications supporting VCs and VPs, the easier and more convenient it will be for the user.
      </p>

      <p>
        Furthermore, TLS and PKIs according to X.509 play an important role as a complement to DIDs.
        They support bootstrapping in terms of trustworthiness and for channel security between two wallets.
        HTTPS in particular is widely used today.
        It ensures the authenticity of (mostly) domain names and provides encrypted transport of data.
        The trust hierarchies in today's PKIs are largely established, and TLS is easy to use as transport security in today's network infrastructures (NAT, firewalls, etc.).
        With more widespread use of DIDs and VCs and the associated trust structures, they can also be used later for server-side authentication, but initially they will only replace the little-used TLS client certificates in a more flexible way.
      </p>

    </section>

    <section id="conformance">
      <p>
        This is required for specifications that contain normative material.
      </p>
    </section>
  </body>
</html>
