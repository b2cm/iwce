<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Inter-Wallet Credential Exchange</title>
    <script
      src="https://www.w3.org/Tools/respec/respec-w3c"
      class="remove"
      defer
    ></script>
    <script class="remove">
      // All config options at https://respec.org/docs/
      var respecConfig = {
        editors: [
            {
              name: "Christoph Menzer",
              url: "blockchain.hs-mittweida.de",
              company: "Hochschule Mittweida",
            }, {
              name: "Sarah Otto",
              url: "blockchain.hs-mittweida.de",
              company: "Hochschule Mittweida",
            },
        ],
        github: "some-org/iwce",
        shortName: "iwce",
        xref: "web-platform",
        group: "my-working-group",
        noRecTrack: true,
        localBiblio: {
          applinks: {
            title: "Handling Android App Links. Android Developers",
            href: "https://developer.android.com/training/app-links",
            publisher: "Google Inc.",
          },
          universallinks: {
            title: "Allowing Apps and Websites to Link to Your Content. Apple Developer Documentation",
            href: "https://developer.apple.com/documentation/uikit/inter-process_communication/allowing_apps_and_websites_to_link_to_your_content",
            publisher: "Apple Inc.",
          },
          didconfiguration: {
            title: "Well Known DID Configuration",
            href: "https://identity.foundation/specs/did-configuration/",
            publisher: "Decentralized Identity Foundation",
          },
        },
      };
    </script>
  </head>
  <body>

    <section id="abstract">

      <p>
        Inter-Wallet Credential Exchange describes a simple way to exchange identity information in a secure, decentralized and scalable manner.
        It uses some standardized data structures, formats and transport protocols to enable applications (particulary identity wallets) from different  manufacturers to communicate with each other, without a third party or an intermediary.
        The main purpose of this approach is to establish a claim-based identity management model in the world wide web.
      </p>

    </section>

    <section id="sotd">
      <p>This is required.</p>
    </section>

    <section class="informative">

      <h2>Introduction</h2>

      <p>
        The Verifiable Credentials Data Model [[vc-data-model]] is used to express simple statements about an entity, like drivers licences, university degrees or government-issued passports etc.
        The ecosystem of this model consists of multiple roles and their actors, which can be identified by some sorts of identifiers.
        This can be Decentralized Identifiers (DIDs) [[did-core]], Uniform Resource Identifiers (URIs) [[rfc3986]], Uniform Resource Locators (URLs) and so on.
        By the use of DIDs and their corresponding DID-Documents, they are fully under control by the owner of this DID.
        Therefore, they have neither trust nor make any statement about the owner itself.
      </p>

      <aside class="note" title="DID-Documents">
        <p>
          It is important to understand, that DID-Documents DOES NOT contain any Personally Identifiable Information (PII).
          They are used to describe some technical information about the identifier only.
          For example, this can be public keys, methods for verification, authentication and assertion, or service endpoints.
        </p>
      </aside>

      <p>
        To address this, Verifiable Credentials (VCs) and their corresponding Verifiable Presentations (VPs) can be used.
        VCs are cryptographically signed by a (allegedly) trusted issuer, that makes claims about a subject.
        This subject is represented by an identifier, for example, a DID.
        VPs are cryptographically signed by the user to prove that he has the DID specified as subject under control.
      </p>

      <p>
        The Inter Wallet Credential Exchange uses DIDs, VCs and VPs in conjunction with HTTPS to transport identity information between two applications directly.
        For best decentralization, the use of special URLs is recommended, known as Universal-Links [[universallinks]] or App-Links [[applinks]] respectively.
        In the case of web applications running on a desktop, in conjunction with a mobile device, these links can be transferred using a QR code.
      </p>

    </section>

    <section>

      <h2>Scope</h2>

      <p>
        This proposal mainly specifies two data structures and their encoding and transport over HTTPS.
        It describes the use of Universal- or App-Links and their advantages in terms of decentralization.
        Furthermore, VCs and an additional special data structure are used so that it is possible for users to disclose only certain personal information, without the complexity of Zero Knowledge Proofs.
      </p>

      <p>
        Out of scope are any semantics of concrete VCs and related data structures.
        Moreover, no detailed implementation instructions are given with regard to different development environments, programming languages or operating systems.
        Another limitation of this specification is the process of issuing the Verifiable Credentials used herein.
        This is done by each service for its own and can be designed individually by the services acting as issuers.
        It is assumed that corresponding Verifiable Credentials have already been issued to a user in an issuer's application.
      </p>

      <p>
        It is explicitly mentioned that Inter-Wallet Credential Exchange is not a solution for single sign-on (SSO).
        It is not about the login process as known today by means of username and password.
        Rather, the aim is to speed up the registration process for new services and to replace the login with passwordless procedures.
        The latter takes place exclusively within a service's own domain (see [[[#sds]]] and [[[#anti-correlation]]]).
        However, the authentication of devices or applications against their own back end is not the actual concern either. The DIDs described here or other asymmetric cryptography are suitable for this (e.g. Web Authentication).
        For existing systems, it is also conceivable that other authentication methods that are currently in widespread use, such as the legacy username and password, or centralized schemes such as OAuth or OpenID, could be used to authenticate within one's domain.
      </p>

    </section>

    <section class="informative">

      <h2>Terms and Definitions</h2>

    </section>

    <section class="informative">

      <h2>Abbreviations and Symbols</h2>

    </section>

    <section>

      <h2>Assumptions</h2>

      <section class="informative"><h2>Decentralized Identifiers</h2>

        <p>
          Decentralized Identifiers as defined in [[did-core]] are a new type of identifier.
          They are generated and controlled by an entity itself.
          The proof of control is provided by cryptographic methods, e.g. by means of digital signatures.
          There is no limit to the number of DIDs an entity can create.
        </p>

        <p>
          A DID contains the designation of a schema, the designation of a DID method, and the the identifier itself. The designators are separated by a colon:
        </p>

        <aside class="example">
          <pre class="json">
            did:example:123456789abcdefghi
          </pre>
        </aside>

        <p>
          The schema denotes that it is a DID. The DID method identifies the way an identifier can be created and managed.
          The W3C maintains an official list of DID methods and their specifications for this purpose [[did-spec-registries]].
          The specification of a DID method contains information about all important operations, such as creating, reading, updating and deleting DIDs.
        </p>

        <p>
          A DID is resolved by a DID resolver into a DID document.
          This contains additional information about a DID, such as further public keys, authentication and authorization methods, or so-called service endpoints.
          The latter are details of services or storage locations that can be linked to the identifier.
          A DID document never contains personal information.
        </p>

        <p>
          The DID method specification also contains all the information that a DID resolver needs to resolve a DID.
          The minimum that a DID method must describe is how the identifier is generated. This is true, for example, for the special Peer DID Method (`did:peer:xyz`), which does not bind to any specific network and is developed for short-duration and bidirectional connections.
          Most DID methods additionally specify a routing information in which network the identifier is to be found.
          Further information, such as the DID document, can then be retrieved here by a DID resolver.
          This can be executed locally or remotely and obtain its information from a blockchain, a Content Addressable Storage (CAS) or any other API.
        </p>

        <p>
          In some DID methods, the identifiers have cryptographic material or a fingerprint of a public key, just as they do in a blockchain.
          In this way, a DID can authenticate directly against a smart contract in the corresponding blockchain. Furthermore, some signature methods such as the Elliptic Curve Digital Signature Algorithm (ECDSA) allow the recovery of the public key directly from the signature.
          This feature makes it possible to use a signed message directly for authentication between two hosts.
          The method for generating the identifier, e.g. a DID or an address in the context of blockchain, is usually known, so it can be easily computed from the public key.
          From this point of view, it is not urgent to keep a DID document as long as the relationship between private key, public key and identifier is computable.
          For example, in the ETHR DID Method (`did:ethr:xyz`) the DID document is created by the DID resolver.
        </p>

      </section>

      <section class="informative" id="selective-disclosure">

        <h2>Verifiable Credentials and Selective Disclosure</h2>

        <p>
          This proposal make use of VCs and VPs according to the [[[vc-data-model]]].
          Additionally it supports a special way implementing the selective disclosure feature.
          This feature gives the credential holder the oppurtunity to choose, which attributes will shown to the verifier.
          To achive this, every attribute value, a credential contains, is hashed with a salt.
          The final verifiable credential will only contain this hashes - the salts and the values are stored in a separate json data object, called the Plaintext Credential.
          The following example will show such a Plaintext Credential and its corresponding VC.
        </p>

        <aside class="example">
          <p>Plaintext Credential</p>
          <pre class="json">
            {
              "id": "did:example:0x1611994c317bed3102D65A93B667Dbe0591Da41c",
              "type": "HashedPlaintextCredential2021",
              "hashAlg": "keccak-256",
              "name": {
                  "value": "Max",
                  "salt": "dc0931a0-60c6-4bc8-a27d-b3fd13e62c63",
                  "hash": "0xd8925653ed000200d2b491bcabe2ea69f378abb91f056993a6d3e3b28ad4ccc4"
              },
              "age": {
                  "value": 20,
                  "salt": "3e9bacd3-aa74-42c1-9895-e490e3931a73",
                  "hash": "0x43bde6fcd11015c6a996206dadd25e149d131c69a7249280bae723c6bad53888"
              },
            }
          </pre>
        </aside>

        <aside class="example">
          <p>Corresponding Verifiable Credential</p>
          <pre class="json">
            {
              "@context": ["https://www.w3.org/2018/credentials/v1",
                  "https://some.example.com/credentials/ld-context/"],
              "type": ["VerifiableCredential"],
              "credentialSubject": {
                  "id": "did:example:0x1611994c317bed3102D65A93B667Dbe0591Da41c",
                  "type": "NameAgeCredential",
                  "name": "0xd8925653ed000200d2b491bcabe2ea69f378abb91f056993a6d3e3b28ad4ccc4",
                  "age": "0x43bde6fcd11015c6a996206dadd25e149d131c69a7249280bae723c6bad53888"
              },
              "issuer": "did:example:0x6d32738382c6389eF0D79045a76411C42Fff3a5e",
              "issuanceDate": "2020-11-30T11:06:39.423520Z",
              "proof": {
                  "type": "EcdsaSecp256k1RecoverySignature2020",
                  "proofPurpose": "assertionMethod",
                  "verificationMethod": "did:example:0x6d32738382c6389eF0D79045a76411C42Fff3a5e",
                  "created": "2020-11-30T11:06:39.497073Z",
                  "jws": "ey..E="
              }
            }
          </pre>
        </aside>

        <p>
          VCs are data structures that make statements about a person or an object according to the principles of claim-based identity and are cryptographically verifiable.
          The claims are simple statements associated with an identifier and some metadata and signed by an issuer.
          Basically, anyone can act as an issuer, e.g., a trusted entity or even oneself.
          The latter type of VCs are called self-issued credentials and are useful, for example, for delegating one's own credential to another identifier.
          What should be considered a trusted entity for certain statements is not part of the proposal.
        </p>

        <p>
          The W3C model envisages three main roles for the participants, any of which can be assumed by anyone: the holder, the issuer and the verifier.
          The issuer represents the critical point.
          Further measures are required to ensure the credibility of the issuer.
        </p>

      </section>

      <section class="informative">

        <h2>Verifiable Credentials and Verifiable Presentations</h2>

        <p>
          The VCs are issued to a subject and its identifier, e.g. a DID.
          The owner of the corresponding private key of this DID is called the holder.
          This holder can generate a VP from one or more VCs, in which he can prove by a signature that he controls the identifier(s) of one or more VCs.
          The aggregation of this information typically expresses some aspect of a person, organization, or other entity.
          He finally sends the VP to a verifier that can cryptographically validate the VC's trustworthiness.
        </p>

        <aside class="example">
          <p>Corresponding Verifiable Presentation</p>
          <pre class="json">
            {
              "@context": [
                "https://www.w3.org/2018/credentials/v1",
              ],
              "type": "VerifiablePresentation",
              "verifiableCredential": [{
                "@context": ["https://www.w3.org/2018/credentials/v1",
                    "https://some.example.com/credentials/ld-context/"],
                "type": ["VerifiableCredential"],
                "credentialSubject": {
                    "id": "did:example:0x1611994c317bed3102D65A93B667Dbe0591Da41c",
                    "type": "NameAgeCredential",
                    "name": "0xd8925653ed000200d2b491bcabe2ea69f378abb91f056993a6d3e3b28ad4ccc4",
                    "age": "0x43bde6fcd11015c6a996206dadd25e149d131c69a7249280bae723c6bad53888"
                },
                "issuer": "did:example:0x6d32738382c6389eF0D79045a76411C42Fff3a5e",
                "issuanceDate": "2020-11-30T11:06:39.423520Z",
                "proof": {
                    "type": "EcdsaSecp256k1RecoverySignature2020",
                    "proofPurpose": "assertionMethod",
                    "verificationMethod": "did:example:0x6d32738382c6389eF0D79045a76411C42Fff3a5e",
                    "created": "2020-11-30T11:06:39.497073Z",
                    "jws": "ey..E="
                }
              }],
              "proof": [{
                  "type": "EcdsaSecp256k1RecoverySignature2020",
                  "proofPurpose": "authentication",
                  "verificationMethod": "did:example:0x1611994c317bed3102D65A93B667Dbe0591Da41c",
                  "challenge": "1f44d55f-f161-4938-a659-f8026467f126",
                  "created": "2020-11-30T11:06:39.497073Z",
                  "jws": "lC..n="
              }]
            }
          </pre>
        </aside>

        <p>
          In addition, a VP itself can also have an identifier.
          The array of proofs then contains a number of proofs about the control of DIDs: one or more for that of the subjects of the VCs and one for that of the VP.
          It is also possible for each of the VCs to be issued to a different identifier.
          For each of these identifiers (subject), the corresponding proof can be included in the array of proofs in the VP.
          A challenge within one or more proofs authenticates for example a session.
        </p>

        <aside class="example">
          <p>Verifiable Presentation containing an ID and several Verifiable Credentials, as well as their associated proofs</p>
          <pre class="nohighlight">
            {
              "@context": [
                "https://www.w3.org/2018/credentials/v1",
              ],
              <span style="color: #008000; font-weight: bold">"id": "did:anotherexample:xyv2-xzpq-q9wa-p7t"</span>,
              "type": "VerifiablePresentation",
              "verifiableCredential": [{
                "@context": ["https://www.w3.org/2018/credentials/v1",
                    "https://some.example.com/credentials/ld-context/"],
                "type": ["VerifiableCredential"],
                "credentialSubject": {
                    <span style="color: #008000; font-weight: bold">"id": "did:example:0x1611994c317bed3102D65A93B667Dbe0591Da41c"</span>,
                    "type": "NameCredential",
                    "name": "0xd8925653ed000200d2b491bcabe2ea69f378abb91f056993a6d3e3b28ad4ccc4",
                },
                "issuer": "did:example:0x6d32738382c6389eF0D79045a76411C42Fff3a5e",
                "issuanceDate": "2020-11-30T11:06:39.423520Z",
                "proof": {
                    "type": "EcdsaSecp256k1RecoverySignature2020",
                    "proofPurpose": "assertionMethod",
                    "verificationMethod": "did:example:0x6d32738382c6389eF0D79045a76411C42Fff3a5e",
                    "created": "2020-11-30T11:06:39.497073Z",
                    "jws": "ey..E="
                }
              }, {
                "@context": ["https://www.w3.org/2018/credentials/v1",
                    "https://some.example.com/credentials/ld-context/"],
                "type": ["VerifiableCredential"],
                "credentialSubject": {
                    <span style="color: #008000; font-weight: bold">"id": "did:example:0x7c0296fb88ec930a2a31361ca1b579603bc18892"</span>,
                    "type": "AgeCredential",
                    "age": "0x43bde6fcd11015c6a996206dadd25e149d131c69a7249280bae723c6bad53888"
                },
                "issuer": "did:example:0x6d32738382c6389eF0D79045a76411C42Fff3a5e",
                "issuanceDate": "2020-11-30T11:06:39.423520Z",
                "proof": {
                    "type": "EcdsaSecp256k1RecoverySignature2020",
                    "proofPurpose": "assertionMethod",
                    "verificationMethod": "did:example:0x6d32738382c6389eF0D79045a76411C42Fff3a5e",
                    "created": "2020-11-30T11:06:39.497073Z",
                    "jws": "da..G"
                }
              }],
              "proof": [{
                  "type": "EcdsaSecp256k1RecoverySignature2020",
                  "proofPurpose": "authentication",
                  <span style="color: #008000; font-weight: bold">"verificationMethod": "did:example:0x1611994c317bed3102D65A93B667Dbe0591Da41c"</span>,
                  "challenge": "1f44d55f-f161-4938-a659-f8026467f126",
                  "created": "2020-11-30T11:06:39.497073Z",
                  "jws": "Lm..v="
                }, {
                  "type": "EcdsaSecp256k1RecoverySignature2020",
                  "proofPurpose": "authentication",
                  <span style="color: #008000; font-weight: bold">"verificationMethod": "did:example:0x7c0296fb88ec930a2a31361ca1b579603bc18892"</span>,
                  "challenge": "1f44d55f-f161-4938-a659-f8026467f126",
                  "created": "2020-11-30T11:06:39.497073Z",
                  "jws": "xS..6"
                }, {
                  "type": "EcdsaSecp256k1RecoverySignature2020",
                  "proofPurpose": "authentication",
                  <span style="color: #008000; font-weight: bold">"verificationMethod": "did:anotherexample:xyv2-xzpq-q9wa-p7t"</span>,
                  "challenge": "1f44d55f-f161-4938-a659-f8026467f126",
                  "created": "2020-11-30T11:06:39.497073Z",
                  "jws": "ui..r"
                }]
            }
          </pre>
        </aside>

      </section>

      <section class="informative">

        <h2>Verifiable Credentials and Revocation</h2>

        <p>
          In addition to an expiration date (`expirationDate` or `validUntil`) for credentials, issuers also have the option to revoke it.
          For this purpose, the [[[vc-data-model]]] defines the property `credentialStatus`, which links to a revocation list.
          This list can be stored on a blockchain, a Content Addressable Storage (CAS) or any other API.
        </p>

        <aside class="example">
          <p>Expiration date and status in a Verifiable Credential</p>
          <pre class="json">
            {
                "expirationDate": "2020-01-01T19:23:24Z",
                "credentialStatus": {
                  "id": "0x06012c8cf97bead5deae237070f9587f8e7a266d",
                  "type": "EthereumMainnetStatusList2021"
                },
            }
        </pre>
        </aside>
      </section>

      <section class="informative" id="uniapplinks">

        <h2>Universal- / App-Links</h2>

        <p>
          Universal or app links are a way in mobile operating systems to retrieve certain data from an app using a URL.
          For Apple's iOS they are documented under the name Universal Links [[universallinks]], for Google they are called Android App Links [[applinks]].
          They are a form of deep links that are handled specifically in the operating systems.
          During the installation of an app, a handler for a specific URL is created in the operating system that uniquely identifies the app.
          To prove ownership of a URL, a check is made for a specific machine-readable document that must be provided under the URL's domain.
          After this check is successful, requests to this URL are passed directly to the installed app without any further interaction from the user.
          Binding to a domain ensures uniqueness and the mandatory use of HTTPS ensures authenticity and secrecy.
        </p>

        <p>
          If a request is made to the URL and there is no corresponding app installed, it will be opened in the browser as usual.
          The request therefore does not end in an error state, but can be answered by the own web server as desired.
          For example, the user gets a hint to install the corresponding app or is redirected to an online application.
        </p>

      </section>

    </section>

    <section>

      <h2>Protocol Flow</h2>

      <section>

        <h2>Credential Request</h2>

        <p>
          To request VCs within a VP the following simple JSON data structure MUST be used, which MUST then be encoded in Base64url [[rfc4648]] and attached as a query.
          The URIs used comply with the [[[rfc3986]]] specification.
          Verifiable Credentials and Verifiable Presentations are compliant to the [[[vc-data-model]]].
        </p>

        <p>
          A Credential Request is defined with the following properties:
          <dl>

          <dt>type</dt>
            <dd>
              The `type` property is required and MUST be an URI. The value `"CredentialRequest"` MUST be used to determine that it is a Credential Request.
            </dd>

          <dt>accept</dt>
            <dd>
              The `accept` property is reqired and describes the accepted data of a response to a request. It is defined with the following properties:
            <dl>

              <dt>type</dt>
              <dd>
                The `type` property is required and MUST be an URI.
                The value `"CredentialResponse"` MUST be used to determine that the requested data is to provided in the form of a Credential Response.
              </dd>

              <dt>verifiablePresentation<dt>
                <dd>
                  The `verifiablePresentation` property is reqired.
                  <dl>

                    <dt>type</dt>
                      <dd>
                        The `type` property is required and MUST be an URI.
                        It denotes the expected type of the Verifiable Presentation.
                      </dd>

                    <dt>credentialTypes</dt>
                      <dd>
                        The `credentialTypes` property is required and MUST be one or more URIs.
                        It denotes the accepted URIs of Verifiable Credentials within a Verifiable Presentation.
                      </dd>
                  </dl>
                </dd>

              <dt>selectiveDisclosure</dt>
                <dd>
                  The `selectiveDisclosure` property is optional. If it is not set, no method for selective disclosure is accepted.
                  <dl>

                  <dt>type</dt>
                    <dd>
                      The `type` property is required and MUST be an URI.
                      It denotes the expected method of the selective disclosure feature.
                    </dd>

                  <dt>requiredProperties</dt>
                    <dd>
                      The `requiredProperties` property is is type specific.
                      For the selective disclosure feature proposed in section [[[#selective-disclosure]]] the `requiredProperties` property MUST be an object that contains one or more sets of strings corresponding to the property names of one or more plaintext credentials that are to be mandatory disclosed.
                      The key of each set MUST correspond to the credential types name as specified in property `credentialTypes`.
                      Which properties are then really returned is not guaranteed and has to be checked in the response.
                    </dd>
                  </dl>
                </dd>
              </dl>
            </dd>

          <dt>responseUrl</dt>
            <dd>
              The `responseUrl` property is reqired and MUST be an URL.
              The location MUST be a ressource with HTTPS enabled. For best decentralization it is RECOMMENDED to use Universal- or App-Links, see section [[[#uniapplinks]]].
            </dd>

          <dt>challenge</dt>
            <dd>
              The `challenge` property is reqired and MUST be a long random number.
              It is RECOMMENDED to use at least 128 bit. For example, an UUID [[rfc4122]] might be helpful for this task.
              The challenge is computed by the verifier and MUST have a Time to Live (TTL).
            </dd>

          <dt>domain</dt>
            <dd>
              The `domain` property is optional and MUST be an URI.
              It is used to announce domain-specific extensions in a Credential Request.
            </dd>
          </dl>
        </p>

        <aside class="example">
          <p>Credential Request data object</p>
          <pre class="json">
            {
                "type": "CredentialRequest",
                "accept": {
                    "type": "CredentialResponse",
                    "verifiablePresentation": {
                        "type": "VerifiablePresentation",
                        "credentialTypes": ["AgeCredential","NameCredential"],
                    },
                    "selectiveDisclosure": {
                        "type": "HashedPlaintextCredential2021",
                        "requiredProperties": {
                            "AgeCredential": ["age"]
                        },
                    }
                },
                "responseUrl": "https://verifier-app.another-example.com/responses",
                "challenge": "1f44d55f-f161-4938-a659-f8026467f126",
                "domain": "example.com"
            }
          </pre>
        </aside>

        <p>
          The encoded JSON data object MUST be attached as a query to the URL of the application that will process the request.
          The encoding scheme MUST be Base64url [[rfc4648]].
        </p>

        <aside class="example">
          <p>Encoded Credential Request</p>
          <pre class="nohighlight">
            https://issuer-app.example.com/requests?<span style="color: #008000; font-weight: bold">eyAidHlwZSI6ICJDc...IgfQ</span>
          </pre>
        </aside>

        <aside class="note" title="QR-Codes">
          <p>
            For use with web applications on a desktop, the URL including the encoded Credential Request can be represented as a QR code.
            Depending on the type used, there may be restrictions on the amount of data that can be encoded.
            Since the challenge has a TTL, the QR code has to be rerendered frequently.
          </p>
        </aside>

      </section>

      <section>

        <h2>Credential Response</h2>

        <p>
          To respond to a request for a VP the following data structure MUST be used, which MUST then be encoded in Base64url [[rfc4648]] and attached as a query. The URIs used comply with the [[[rfc3986]]] specification. Verifiable Credentials and Verifiable Presentations are compliant to the [[[vc-data-model]]].
        </p>

        <p>
          <dl>

            <dt>type</dt>
              <dd>
                The `type` property is required and MUST be an URI.
                The value `"CredentialResponse"` MUST be used to determine that it is a Credential Response.
              </dd>

            <dt>verifiablePresentation</dt>
              <dd>
                The `verifiablePresentation` property is required and defined as an object that contain exactly one Verifiable Presentation.
                The proofs within a Verifiable Presentation MUST contain the `challenge` property that was received with a Credential Request.
                The proofs can also contain the `domain` property to announce domain-specific extensions
              </dd>

            <dt>selectiveDisclosure<dt>
              <dd>
                The `selectiveDisclosure` property is optional.
                If it is not set, no method for selective disclosure is supported.
                <dl>
                  <dt>plaintextCredential</dt>
                    <dd>
                      The `plaintextCredential` property is type specific.
                      The expected return value is data conforming to the type information from a credential request.
                      For the selective disclosure feature proposed in section [[[#selective-disclosure]]] the `plaintextCredential` property is defined as a set of objects that contain one or more Plaintext Credentials (`HashedPlaintextCredential2021`).
                    </dd>
                </dl>
              </dd>
          </dl>
        </p>

          <aside class="example">
            <p>Credential Response data object</p>
            <pre class="json">
              {
                  "type": "CredentialResponse",
                  "verifiablePresentation": {},
                  "selectiveDisclosure": {
                      "plaintextCredential": [{},{}]
                  }
              }
            </pre>
          </aside>

        <p>
          This encoded JSON data object MUST be attached as a query to the URL of the application that will process the response. The encoding scheme MUST be Base64url [[rfc4648]].
        </p>

        <aside class="example">
          <p>Encoded Credential Response</p>
          <pre class="nohighlight">
            https://verifier-app.another-example.com/responses?<span style="color: #008000; font-weight: bold">JWZXJpZmlhYmxlUHJ...JodH</span>
          </pre>
        </aside>

      </section>

    </section>

    <section id="sds">

      <h2>Strict domain separation</h2>

      <p>
        The use of multiple proofs in a VP makes it possible to strictly separate the domains of identity information.
        For best decentralization, VCs SHOULD only be issued within a domain and SHOULD only be stored in a domains own application.
        To be faithful to the concept of Inter-Wallet Credential Exchange, the only way to exchange VCs with external or third-party applications MUST be the use of VPs.
        The private key of a subject's identifier MUST NOT leave its own applications within a domain.
        This has several advantages:
      </p>

      <ul>
        <li>an issuer can decide how to store the private keys of a subject for which it issues Verifiable Credentials (security levels)</li>
        <li>an issuer can enforce security mechanisms such as two-factor authentication</li>
        <li>an issuer can customize the issuance process to meet its specific needs</li>
        <li>areas of responsibility are clearly delineated</li>
        <li>personal data is managed where it already exists, within a domain</li>
        <li>an issuer can decide which properties a user really will disclose and share across the own domain</li>
      </ul>

      <p>
        Since the proofs in a VP can be made with different identifiers, an issuers application is able to interoperate with different types of identifiers.
        For example, the identfier of a VP can be an address in Blockchain A and the identfiers of the VCs are DIDs anchored in Blockchain B.
        The latter is a blockchain in the issuer's domain, blockchain A is that of a third party application.
        In that way a user can prove control over an address in any blockchain or any other identfier in combination with verifiable personal information.
        For this to work, both issuer and verifier MUST implement all methods of the identifiers used.
      </p>

      <p>
        The issuing process is domain specific and an issuer decides what types of identifiers he is using for its own VCs.
        An issuer SHOULD use DIDs as specified in [[[did-core]]] to authenticate a VC on a device (`id` of `credentialSubject`) to the own back end.
        An issuer MAY use DIDs for the `issuer` property to authenticate itself to the verifier.
        In that case the [[[didconfiguration]]] SHOULD be used for trust, see [[[#trust]]] for more details.
      </p>

    </section>

    <section class="informative">

      <h2>User Experience</h2>

      <p>
        Considerations about end-user experience are closely related to the use of app/universal links and VCs/VPs.
        App/Universal links enable a seemless user experience during exchange of VPs between apps on the user's device, because, when implemented correctly, they identify the app the operating system should open.
        Additionally, these links are normal URLs and can be represented in any form a URL can take, e.g. as QR-Code.
        Therefore, an exchange between different devices (smartphone and desktop) is possible without loss in user-experience, because the QR-code can be scanned with every app capable of doing so and the user is redirected to the requested app.
      </p>

      <p>
        With VCs/VPs it is possible to exchange personal Information in a verifiable and data-conserving manner.
        In most use-cases they simplify the disclosure of these information during for example a registration process.
        Using VCs/VPs the user must not input the information by hand but only has to send a VP.
        The service requesting the information could rely on them, because they are signed by an issuer (Only if the service trusts the issuer).
      </p>

      <p>
        Additionally, this proposal enables every service-provider that has an own app including credential and their exchange functionality in its own app without relying on a central so called identity wallet to store the issued credential.
        From the user perspective he/she only has to rely on the issuer and its application, not in an intermediary wallet service/app for storing the credentials.
      </p>

    </section>

    <section class="informative">

      <h2>Security Considerations</h2>

      <section>

        <h2>Perfect Forward Secrecy</h2>

        <p>
          Because of HTTPS is used to transport Credential Requests and Credential Responses between two applications, Perfect Forward Secrecy (PFS) is substantial in most of the abailable implementations.
          Please note, that this applies only to the network connection while requests or responses are made.
          The including VP and its VCs signed by the holder and one or more issuers are unaffected.
          When using QR codes for a request, this security requirement is obsolete.
        </p>

        <p>
          Since TLS operates in the network layer, it ensures that the information transferred within a URL is also protected (e.g. a query).
        </p>

      </section>

      <section id="trust">

        <h2>Trust</h2>

        <p>
          Because of HTTPS is used to transport Credential Requests and Credential Responses between two applications, the underlying PKI system of TLS (X.509) builds trust for this connection, in that way, that the communication endpoints are the intended ones.
          This is helpful to identify the applications that want to do a credential exchange.
        </p>

        <p>
          Since DIDs are out of trust HTTPS can be used to map a DID to a domain.
          This is most useful for issuers, since larger institutions usually use TLS certificates these days anyway.
          The [[[didconfiguration]]] specification describes an approach which makes use of Well-Known URIs [[rfc8615]].
        </p>

      </section>

    </section>

    <section class="informative">

      <h2>Privacy Considerations</h2>

      <section id="anti-correlation">

        <h2>Anti-correlation</h2>

        <p>
          An important goal in dealing with digital identities is to avoid or at least make it more difficult to conduct in-depth analyses of user behavior.
          The concept of SSO in particular does exactly the opposite, even across multiple services and for each individual login process.
          In the approach of the Inter-Wallet Credential Exchange, this is complicated by two conceptual measures.
          First, technical authentication via DIDs or other types of identfiers takes place only within the domain of a single service and is strictly separated from the exchange of a user's identity information across domain boundaries (see section [[[#sds]]]).
          Second, even the identifiers, e.g., in the form of a DID, are not limited to a single, unique one per user when used in VCs, so each VC should have a different identifier.
        </p>

        <p>
          Individual aspects of a digital identity are only stored within the app of a service that acts as issuer for it.
          Other services that trust the aforementioned service as issuer and are interested in these individual aspects of that identity can submit a request to the app of this issuer to return a VP.
          Further aspects of a digital identity can in turn be requested from apps of other services or issuers in the same way.
          Each app acts as a wallet software and stores private keys that never leave it and are used to authenticate with its own back-end (e.g., DID Auth).
          Services acting as issuers also store the VCs they issue themselves only in their own apps on the end devices of the users (and possibly as a backup in their own back end).
          Only this app is ultimately able to sign a requested VP because only it has the corresponding private keys.
          The user's own digital identity is thus formed from a large number of apps from different manufacturers or services, which exchange VPs with each other.
          As a result the correlation of personal data by intermediaries is made more difficult and decentralization is achieved to a high degree by the direct exchange of identity information between two apps directly.
          The private keys stored in the respective apps also relieve the user of the need to enter passwords.
        </p>

      </section>

    </section>

    <section class="informative">

      <h2>Bootstrapping</h2>

      <p>
        For an app that is launched for the first time and wants to communicate with its back end, the omission of passwords requires that at least one other app is installed on the user's device that provides a VC accepted by the first app.
        By sending a DID, the back-end system merely learns about a new device, but does not yet have any verifiable information about the user and his identity.
        If no app from another trusted issuer can be relied upon, a newly computed DID must be associated with a digital identity in some other way.
        In the worst case, the user must visit an issuer in person and identify himself to him (ID card, driver's license, etc.) and transmit the corresponding DID (e.g., by QR code).
        It is also conceivable that some issuers will additionally offer other procedures for establishing identity.
        For example, the combination with an online ID function of the ID card could be a suitable starting point for some issuers.
        In addition, government agencies could also act as issuers and offer VCs in their apps after authentication with the ID card has been successful.
        RFID cards, PINs/TANs/links via mail or e-mail, second devices, and many more are also ways to support bootstrapping during the initial launch of an application on a new end device which will support VCs/VPs.
        The greater the variety of applications that support VCs and VPs, the easier and more convenient it will be for the user.
      </p>

      <p>
        Furthermore, Transport Layer Security (TLS) and PKIs according to X.509 play an important role as a complement to DIDs.
        They support bootstrapping in terms of trustworthiness and for channel security between a wallet and a service.
        HTTPS in particular is widely used today.
        It ensures the authenticity of (mostly) domain names and provides encrypted transport of data.
        The trust hierarchies in today's PKIs are largely established, and TLS is easy to use as transport security in today's network infrastructures (NAT, firewalls, etc.).
        With more widespread use of DIDs and VCs and the associated trust structures, these can also be used later for server-side authentication, but initially they will only replace the little-used TLS client certificates in a more flexible way.
      </p>

    </section>

    <section id="conformance">
      <p>
        This is required for specifications that contain normative material.
      </p>
    </section>
  </body>
</html>
